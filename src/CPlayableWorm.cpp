#include "CPlayableWorm.h"
#include <sstream>

/** Inicialize variables. 
* @param name worm's name
* @param color worm's color
*/
CPlayableWorm::CPlayableWorm (const string name , int color):CWorm(name,color){
    m_Refreshed = true;
    m_Moved = false;
    m_ChangedDirection = -1;
    m_NextStep = 0;
}

/** This method return data which can be sended through network.  Output string contains
* "0" if worm is not active.
* 'r' if only change direction and then the direction ('1' left or '0' right).
* 'n' if direction has been changed and then number of direction and the next part.
* @return String of the last worm's body part. String ended with ';' and the values are separate with ','
*/
string CPlayableWorm::getInfo ( void ) {
    string output;
    std::ostringstream *intToStr;
    if(!m_Active) return "0;";

    if(m_ChangedDirection != -1){
        if(m_NextStep){
            output = "r";
            output += m_ChangedDirection+48;
            m_ChangedDirection = -1;
        }else{
            output = "n";
            output += m_ChangedDirection+48;
            m_ChangedDirection = -1;
            output += ";";
            return output;
        }       
    }

    intToStr = new std::ostringstream();
    *intToStr << m_LastPart->m_X;
    output += intToStr->str();
    output += ',';
    delete intToStr;
    intToStr = new std::ostringstream();
    *intToStr << m_LastPart->m_Y;
    output += intToStr->str();
    delete intToStr;
    output += ',';
    output += m_Direction+48;
    output += ',';
    intToStr = new std::ostringstream();
    *intToStr << m_LastPart->m_Part;
    output += intToStr->str();
    output += ';';
    delete intToStr;
    
    return output;

}

/** Move worm to the next position. Process data generated by getInfo() method.
* Then printed the new data.
* @param input the data from another CPlayableWorm object
* @return 1 if worm is inactive and 0 if is active and moved.
*/
int CPlayableWorm::moveWorm ( const string & input ){
    if(!m_Active) return 1;
    if(input[0] == '0') {m_Active = false; return 1;}
    if(m_Moved) {m_Moved = false; return 0;}
    int part =0 ;
    string data = input, tmp;
    std::istringstream *is;

    if(data[0] == 'r'){
        this->directionChange(data[1]-48);
        data = data.substr(2, data.length());
    }else if(data[0] == 'n'){
        this->directionChange(data[1]-48);
        data = data.substr(2, data.length());
        return 0;
    }

    int len = data.find_first_of(',');
    tmp = data.substr(0,len);
    is = new std::istringstream(tmp);
    *is >> m_PosX;
    delete is; 
    data = data.substr(len+1, data.length());
    len = data.find_first_of(',');
    is = new std::istringstream(data.substr(0,len));
    *is >> m_PosY;
    delete is;
    data = data.substr(len+1, data.length());
    m_Direction = data[0]-48;
    data = data.substr(2, data.length());
    len = data.find_first_of(';');
    is = new std::istringstream(data.substr(0,len));
    *is >> part;
    delete is;

     TChars *buffer = new TChars(m_PosY, m_PosX, part);

    attron(COLOR_PAIR(m_Color));
    mvaddch(buffer->m_Y, buffer->m_X, buffer->m_Part);
    attroff(COLOR_PAIR(m_Color));

    if(!m_CountParts){
        m_FirstPart = m_LastPart = buffer;
        m_CountParts = 1;
    }else{
        m_LastPart->m_Next = buffer;
        m_LastPart = buffer;
        m_CountParts++;
        m_Score++;
    }
    m_Moved = true;
    m_Refreshed = true;
    m_NextStep++;
    return 0;
}

/** Move worm to the next position.
* @return 1 if worm is inactive else 0.
*/
int CPlayableWorm::moveWorm ( void ){
    if(!m_Active) return 1;
    if(m_Moved) {m_Moved = false; return 0;}
    int character;
    switch(m_Direction){
        case UP:
            m_PosY--;
            character = ACS_VLINE;
            break;
        case DOWN:
            m_PosY++;
            character = ACS_VLINE;
            break;
        case LEFT:
            m_PosX--;
            character = ACS_HLINE;
            break;
        case RIGHT:
            m_PosX++;
            character = ACS_HLINE;
            break;
    }

    if(this->clearWay(m_PosX, m_PosY)){
        m_Active = false;
        return 1;
    }

    TChars *buffer = new TChars(m_PosY, m_PosX, character);

    attron(COLOR_PAIR(m_Color)); 
    mvaddch(buffer->m_Y, buffer->m_X, buffer->m_Part);
    attroff(COLOR_PAIR(m_Color)); 
    m_LastPart->m_Next = buffer;
    m_LastPart = buffer;

    m_Score++;
    m_Refreshed = true;
    m_NextStep++;
    return 0;   
}

/** 
* Change worm direction. Change last body part to corner and reprinted it.
* You can turn only left or right. So the calculation of the new direction
* depends on direction before. Also change variables m_ChangedDirection to 
* direction and m_NextStep set to 0.
* @param direction 1 is left and 0 is right
*/
void CPlayableWorm::directionChange ( int direction ){
    if(!m_Active) return;
    m_ChangedDirection = direction;
    m_NextStep = 0;
    direction = (direction ? LEFT : RIGHT );
    switch(m_Direction){
        case UP:
            if(direction == LEFT)
                m_LastPart->m_Part = ACS_URCORNER;
            else
                m_LastPart->m_Part = ACS_ULCORNER;
            m_Direction = direction;            
            break;
        case DOWN:
            if(direction == LEFT){
                m_LastPart->m_Part = ACS_LLCORNER;
                m_Direction = RIGHT;
            }else{
                m_LastPart->m_Part = ACS_LRCORNER;
                m_Direction = LEFT;
            }
            break;
        case LEFT:
            if(direction == LEFT){
                m_LastPart->m_Part = ACS_ULCORNER;
                m_Direction = DOWN;
            }else{
                m_LastPart->m_Part = ACS_LLCORNER;
                m_Direction = UP;

            }
            break;
        case RIGHT:
            if(direction == LEFT){
                m_LastPart->m_Part = ACS_LRCORNER;
                m_Direction = UP;
            }else{
                m_LastPart->m_Part = ACS_URCORNER;
                m_Direction = DOWN;
            }

            break;
    }
    attron(COLOR_PAIR(m_Color)); 
    mvaddch(m_LastPart->m_Y, m_LastPart->m_X, m_LastPart->m_Part);
    attroff(COLOR_PAIR(m_Color)); 

    m_Refreshed =false;
    return;
}



